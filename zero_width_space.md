# 零宽度字符

来源：2022日月盾杯【怎么看不见？】

[![Zh7RUr.png](https://www.helloimg.com/images/2022/11/19/Zh7RUr.png)](https://www.helloimg.com/image/Zh7RUr)



实际上：

[![Zh7FH1.png](https://www.helloimg.com/images/2022/11/19/Zh7FH1.png)](https://www.helloimg.com/image/Zh7FH1)



## 什么是零宽度字符

> 零宽度字符是一种字节宽度为0的不可打印的[Unicode](https://so.csdn.net/so/search?q=Unicode&spm=1001.2101.3001.7020)字符, 在浏览器等环境不可见, 但是真是存在, 获取字符串长度时也会占位置, 表示某一种控制功能的字符。

零宽度字符主要用于控制词与词之间，行与行之间的排版问题，就好比一个由两个单词连在一起组成的词[eg.helloworld]，如果仅仅是由可见字符组成的话，那么双击这个词会将整个词选中，但是如果想要在双击hello时仅选中hello而不选中world的话，可以在hello和world之间加上零宽度字符

所以零宽度字符可以理解为宽度为零的空格（有些也不是空格），看不见但是实际存在（压缩了？）



## 如何判断是否存在零宽度字符

以下是题目涉及到的密文（如果其中的密文没有因为编码等问题丢失的话）

> 在这→‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌‌←

以下是几种判断的方式

- 将以上文本复制到本地的任意文本文件中，将光标移至文本开头，逐次按下右方向键，会发现在箭头之间时需要不止一次移动才能移动至下一个字符

- 将密文复制到文本文件中保存并在Linux命令行中使用vim打开，可以直接看到零宽度字符

  [![Zh7ehS.png](https://www.helloimg.com/images/2022/11/19/Zh7ehS.png)](https://www.helloimg.com/image/Zh7ehS)

- 使用各种工具：cyberchef(自己下载)、steganography([Unicode Steganography with Zero-Width Characters (330k.github.io)](https://330k.github.io/misc_tools/unicode_steganography.html))

  [![Zh7xxC.png](https://www.helloimg.com/images/2022/11/19/Zh7xxC.png)](https://www.helloimg.com/image/Zh7xxC)

  [![Zh7Jgt.png](https://www.helloimg.com/images/2022/11/19/Zh7Jgt.png)](https://www.helloimg.com/image/Zh7Jgt)



## 题解

所以这道题怎么解？

由于零宽度字符仅是一种隐藏信息的方式，实际上的解法还需要根据实际情况判断（好比一串随机字符可以是经过凯撒加密也可以是经过维吉尼亚加密的结果）

---

将cyberchef的结果复制到本地，用Python处理一下：由于密文中的信息仅有两种符号，故用两种符号表示

```python
>>> s = "5728 8fd9 2192 200b 200c 200b 200b 200b 200b 200c 200c 200b 200b 200c 200c 200b 200c 200b 200b 200b 200b 200c 200c 200b 200b 200b 200b 200b 200b 200c 200c 200b 200c 200b 200b 200b 200c 200c 200c 200c 200b 200c 200c 200b 200c 200b 200c 200c 200b 200c 200b 200b 200b 200c 200c 200b 200b 200c 200c 200b 200c 200b 200c 200b 200b 200c 200b 200b 200b 200c 200c 200b 200b 200b 200b 200b 200b 200c 200b 200c 200c 200b 200c 200b 200c 200b 200c 200b 200c 200c 200c 200b 200c 200c 200b 200c 200c 200b 200b 200b 200c 200c 200b 200b 200c 200b 200b 200b 200b 200c 200c 200b 200c 200c 200c 200b 200c 200c 200b 200c 200b 200b 200b 200b 200c 200c 200c 200c 200c 200b 200c 200b 200b 200b 200b 200c 200c 200b 200c 200b 200b 200b 200b 200c 200b 200c 200b 2190"
>>> asd = s.split(' ')
>>> asd
['5728', '8fd9', '2192', '200b', '200c', '200b', '200b', '200b', '200b', '200c', '200c', '200b', '200b', '200c', '200c', '200b', '200c', '200b', '200b', '200b', '200b', '200c', '200c', '200b', '200b', '200b', '200b', '200b', '200b', '200c', '200c', '200b', '200c', '200b', '200b', '200b', '200c', '200c', '200c', '200c', '200b', '200c', '200c', '200b', '200c', '200b', '200c', '200c', '200b', '200c', '200b', '200b', '200b', '200c', '200c', '200b', '200b', '200c', '200c', '200b', '200c', '200b', '200c', '200b', '200b', '200c', '200b', '200b', '200b', '200c', '200c', '200b', '200b', '200b', '200b', '200b', '200b', '200c', '200b', '200c', '200c', '200b', '200c', '200b', '200c', '200b', '200c', '200b', '200c', '200c', '200c', '200b', '200c', '200c', '200b', '200c', '200c', '200b', '200b', '200b', '200c', '200c', '200b', '200b', '200c', '200b', '200b', '200b', '200b', '200c', '200c', '200b', '200c', '200c', '200c', '200b', '200c', '200c', '200b', '200c', '200b', '200b', '200b', '200b', '200c', '200c', '200c', '200c', '200c', '200b', '200c', '200b', '200b', '200b', '200b', '200c', '200c', '200b', '200c', '200b', '200b', '200b', '200b', '200c', '200b', '200c', '200b', '2190']
>>> for i in asd:
	if i == '200b':
		print('1',end='')
	elif i == '200c':
		print('0',end='')
		
101111001100101111001111110010111000010010100101110011001010110111001111110100101010100010010011100110111100100010010111100000101111001011110101
```

这样便得到了密文

然后就是判断究竟是什么加密方式了

一开始觉得是摩斯密码，但是如果是摩斯密码应该还有分隔符，故排除

然后便是考虑ascii码了，ascii码使用8位二进制数表示一个字符，而得到的密文长度刚好能够被8整除

```python
>>> zxc = "101111001100101111001111110010111000010010100101110011001010110111001111110100101010100010010011100110111100100010010111100000101111001011110101"
>>> len(zxc)
144
>>> 144/8
18.0
```

然后便是以8为间隔将密文分为几部分，再将每一部分（字符串）转换为二进制数后转为十进制数，然后再转换为字符

```python
>>> for i in range(0, 18):
	print(chr(int(zxc[8*i:8*(i+1)], 2)), end='')
	
¼ËÏË¥Ì­ÏÒ¨Èòõ
```

……

本来还以为是要以16位为单位再转换为字符，后来失败了，仔细想想有可能是因为一开始0和1的表示就反了，于是将0和1反过来重新试一试

```python
>>> for i in asd:
	if i == '200b':
		print('0',end='')
	elif i == '200c':
		print('1',end='')

010000110011010000110000001101000111101101011010001100110101001000110000001011010101011101101100011001000011011101101000011111010000110100001010
>>> asdasd = "010000110011010000110000001101000111101101011010001100110101001000110000001011010101011101101100011001000011011101101000011111010000110100001010"

>>> for i in range(0, 18):
	print(chr(int(asdasd[8*i:8*(i+1)], 2)),end='')

C404{Z3R0-Wld7h}
```

THE END



完整代码：

```python
s = "5728 8fd9 2192 200b 200c 200b 200b 200b 200b 200c 200c 200b 200b 200c 200c 200b 200c 200b 200b 200b 200b 200c 200c 200b 200b 200b 200b 200b 200b 200c 200c 200b 200c 200b 200b 200b 200c 200c 200c 200c 200b 200c 200c 200b 200c 200b 200c 200c 200b 200c 200b 200b 200b 200c 200c 200b 200b 200c 200c 200b 200c 200b 200c 200b 200b 200c 200b 200b 200b 200c 200c 200b 200b 200b 200b 200b 200b 200c 200b 200c 200c 200b 200c 200b 200c 200b 200c 200b 200c 200c 200c 200b 200c 200c 200b 200c 200c 200b 200b 200b 200c 200c 200b 200b 200c 200b 200b 200b 200b 200c 200c 200b 200c 200c 200c 200b 200c 200c 200b 200c 200b 200b 200b 200b 200c 200c 200c 200c 200c 200b 200c 200b 200b 200b 200b 200c 200c 200b 200c 200b 200b 200b 200b 200c 200b 200c 200b 2190"
asd = s.split(' ')

asdasd = ""

for i in asd:
    if i == '200b':
            asdasd += '0'
    elif i == '200c':
            asdasd += '1'

for i in range(0, 18):
    print(chr(int(asdasd[8*i:8*(i+1)], 2)),end='')
```



**Reference**

> [misc学习笔记1-txt零宽度字符隐写_Amherstieae的博客-CSDN博客_txt隐写](https://blog.csdn.net/Amherstieae/article/details/108909743)
>
> [零宽度字符隐写（CTF）_Hardworking666的博客-CSDN博客](https://blog.csdn.net/Hardworking666/article/details/122278638)

